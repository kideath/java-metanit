https://metanit.com/java/tutorial/1.1.php

Введение в Java
Язык программирования Java

Oracle JDK и OpenJDK
В плане функционала, набора возможностей Oracle JDK и OpenJDK практически не должны отличаться. А вот вплане производительности отмечается, что Oracle JDK работает несколько быстрее, чем OpenJDK. Кроме того, некоторые разработчики отмечают, что OpenJDK чуть более глючная, а Oracle JDK более стабильная.

Загрузить и установить соответствующую версию JDK можно с с официального сайта Oracle: https://www.oracle.com/java/technologies/javase-downloads.html

Итак, перейдем непосредственно на страницу загрузки последней - 16-й версии на страницу https://www.oracle.com/java/technologies/javase-jdk16-downloads.html.

https://adoptopenjdk.net/
https://jdk.java.net/16/





Path=C:\app\Python\Python37\Scripts\;
C:\app\Python\Python37\;C:\Python38\Scripts\;C:\Python38\;
C:\Program Files (x86)\Common Files\Oracle\Java\javapath;
JAVA_HOME=c:\app\Java\jdk-16


Затем cкомпилируем программу с помощью команды
C:\Java>"C:\Program Files\Java\jdk-16\bin\javac" Program.java
%JAVA_HOME%\bin\javac Program.java
%JAVA_HOME%\bin\java Program



tomcat 85
c:\app\Tomcat85\bin\
c:\app\Java\jre1.8.0_221\bin\server\jvm.dll



IntelliJ IDEA
Прежде всего загрузим установочный дистрибутив с официального сайта https://www.jetbrains.com/idea/download. 

How to set editor theme in IntelliJ Idea
OK I found the problem, I was checking in the wrong place which is for the whole IDE's look and feel at File->Settings->Appearance

https://netbeans.apache.org/









Основы программирования на Java
https://metanit.com/java/tutorial/2.11.php




В JDK 8 был инструмент javapackager, предназначенный для JavaFX. Однако после отделения JavaFX от Java вместе с выпуском JDK 11, популярный javapackager оказался более не доступным.

Как известно, Java NIO (New IO) File API существует с JDK 1.4,, а затем было представлено новое усовершенствование под названием Path. Path — это интерфейс, который заменяет класс java.io.File как представление файла или каталога, когда мы работаем в Java NIO.

Так вот, API HTTP Client теперь официально входит в Java SE 11. Это вводит новый модуль и пакет для JDK, java.net.http. Основные новые типы: 
HttpClient
HttpRequest
HttpResponse
WebSocket

Возможно, изменение в String — одно из самых важных в API JDK 11. Здесь есть несколько полезных новых методов.

java.nio.file.Files

Stream

Lambda

Optional

try-with-resources

NioSocketImpl. - Java 13





------------------------
ГЛАВА 3 Классы. Объектно-ориентированное программирование

Инициализаторы

Статический импорт


И затем вместо непосредственной работы с полями name и age в классе Person мы будем работать с методами, которые устанавливают и возвращают значения этих полей. 
Методы setName, setAge и наподобие еще называют мьютейтерами (mutator), так как они изменяют значения поля. 
А методы getName, getAge и наподобие называют аксессерами (accessor), так как с их помощью мы получаем значение поля.


Статические инициализаторы


Классы могут быть вложенными (nested), то есть могут быть определены внури других классов. 
Частным случаем вложенных классов являются внутренние классы (inner class). Например, имеется класс Person, внутри которого определен класс Account:


Еще одной особенностью внутренних классов является то, что их можно объявить внутри любого контекста, в том числе внутри метода и даже в цикле:



Запрет наследования
public final class Person {
}


Кроме запрета наследования можно также запретить переопределение отдельных методов. Например, в примере выше переопределен метод display(), запретим его переопределение:
public final void display(){



Это так называемое восходящее преобразование (от подкласса внизу к суперклассу вверху иерархии) или upcasting. Такое преобразование осуществляется автоматически.






Константы в интерфейсах

Кроме методов в интерфейсах могут быть определены статические константы:
interface Stateable{
 
    int OPEN = 1;
    int CLOSED = 0;
     
    void printState(int n);
}
Хотя такие константы также не имеют модификаторов, но по умолчанию они имеют модификатор доступа public static final, и поэтому их значение доступно из любого места программы.





--------------
STOP: Интерфейсы в механизме обратного вызова



        // Каждое перечисление имеет статический метод values(). Он возвращает массив всех констант перечисления:
        Type[] types = Type.values();
        for (Type s : types) { System.out.println(s); }

можно определять методы для отдельных констант перечислений enum:		


Обобщения (Generics)

Records
Этот конструктор называется каноническим. Он принимает параметры, которые называются также как и поля record, и передает полям значения соответствующих параметров.




В record нельзя явным образом определять нестатические поля и инициализаторы. Но можно определять статические переменные и инициализаторы, также как статические и нестатические методы




Глава 4. Обработка исключений
Базовым классом для всех исключений является класс Throwable. От него уже наследуются два класса: Error и Exception. Все остальные классы являются производными от этих двух классов.

Некоторые из классов непроверяемых исключений:
    ArithmeticException: исключение, возникающее при делении на ноль
    IndexOutOfBoundException: индекс вне границ массива
    IllegalArgumentException: использование неверного аргумента при вызове метода
    NullPointerException: использование пустой ссылки
    NumberFormatException: ошибка преобразования строки в число

Все остальные классы, образованные от класса Exception, называются проверяемыми исключениями (checked exceptions).
Некоторые из классов проверяемых исключений:
    CloneNotSupportedException: класс, для объекта которого вызывается клонирование, не реализует интерфейс Cloneable
    InterruptedException: поток прерван другим потоком
    ClassNotFoundException: невозможно найти класс

		
		
Коллекции
Типы коллекций. Интерфейс Collection

    Collection: базовый интерфейс для всех коллекций и других интерфейсов коллекций
    Queue: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди
    Deque: наследует интерфейс Queue и представляет функционал для двунаправленных очередей
    List: наследует интерфейс Collection и представляет функциональность простых списков
    Set: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов
    SortedSet: расширяет интерфейс Set для создания сортированных коллекций
    NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию
    Map: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection

С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:
    ArrayList: простой список объектов
    LinkedList: представляет связанный список
    ArrayDeque: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце
    HashSet: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код
    TreeSet: набор отсортированных объектов в виде дерева
    LinkedHashSet: связанное хеш-множество
    PriorityQueue: очередь приоритетов
    HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение
    TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение


Очереди и класс ArrayDeque

